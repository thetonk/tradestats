#+title: Ενσωματωμένα Συστήματα Πραγματικού Χρόνου - Report
#+author:
#+latex_header_extra: \input{~/.doom.d/fancyLatexTemplate.tex}
#+STARTUP:inline-images
#+STARTUP:latexpreview
#+OPTIONS: toc:nil date:nil ^:{}
#+BIBLIOGRAPHY: bibliography.bib
#+cite_export: biblatex ieee
#+export_file_name: report

* Σύνοψη
Η παρούσα αναφορά έχει θέμα το πρόγραμμα που υλοποίησα στο πλαίσιο της εργασίας του μαθήματος των ενσωματωμένων συστημάτων πραγματικού χρόνου για το ακαδημαϊκό έτος 2023-2024. Πιο συγκεκριμένα, θα περιγραφεί αναλυτικά η υλοποίηση του προγράμματος και θα παρουσιαστούν τα αποτελέσματα από την χρήση του, ώστε να αποδειχθεί πως ικανοποιεί τις απαιτούμενες προϋποθέσεις μιας εφαρμογής που εκτελείται σε ένα ενσωματωμένο σύστημα για οσοδήποτε μεγάλο χρονικό διάστημα.
** Πηγαίος κώδικας, compilation και χρήση
Ο πηγαίος κώδικας είναι διαθέσιμος στο [[https://github.com/thetonk/tradestats][GitHub]]. Για οδηγίες σχετικά με το compilation και την χρήση του μπορούν να βρεθούν στο σχετικό [[https://github.com/thetonk/tradestats/blob/main/README.md][README]] που δημιουργήθηκε για αυτό το σκοπό.
* Περιγραφή του προγράμματος
** Βιβλιοθήκες
Το πρόγραμμα χρησιμοποεί την βιβλιοθήκη /libwebsockets/ για την απαιτούμενη συνδεσιμότητα μέσω του πρωτοκόλλου websocket με το [[https://finnhub.io][FinnHub]]. Επίσης, χρησιμοποιεί την /pthreads/ για την δημιουργία νημάτων για την επεξεργασία σε πραγματικό χρόνο. Τέλος, για την εύκολη, γρήγορη και αξιόπιστη επεξεργασία των απαντήσεων του server οι οποίες είναι σε μορφή JSON χρησιμοποιήθηκε η βιβλιοθήκη /cJSON/.
** Υλοποίηση
Το πρόγραμμα διαβάζει ένα αρχείο που περιέχει τα σύμβολα του ενδιαφέροντας μας, όπως το /[[https://github.com/thetonk/tradestats/blob/main/symbols.txt][symbols.txt]]/ και το κλειδί του API του FinnHub που απαιτείται για την σύνδεση με τον server. Έπειτα ταξινομεί τα σύμβολα αλφαβητικά μέσω του αλγορίθμου QuickSort[cite:@enwiki:1241885213] ώστε να μπορούμε έπειτα να τα αναζητάμε εύκολα μέσω της χρήσης Binary Search που εγγυάται χαμηλή πολυπλοκότητα[cite:@enwiki:1242941867]. Η αναζήτηση αυτή συμβαίνει πολύ συχνά, διότι απαιτείται κατά την λήψη των δεδομένων ώστε να γίνεται η αντιστοίχηση των συναλλαγών μέσω τα στατιστικά του συμβόλου στο οποίο ανήκουν.\\

Έπειτα, δημιουργούνται συνολικά 5 νήματα αναλαμβάνουν το καθένα από μία αρμοδιότητα:
- Λήψη δεδομένων από τον server, μέσω websockets, και διαχείρηση της σύνδεσης
- Υπολογισμός candlestick
- Υπολογισμός κινούμενου απλού μέσου όρου (SMA) των τελευταίων 15 λεπτών
- Αποθήκευση των στατιστικών σε αρχείο κάθε 1 λεπτό, όταν αυτό απαιτείται
- Αποθήκευση όλων των συναλλαγών σε αρχεία, μόλις ληφθούν

Οι εισερχόμενες συναλλαγές διοχετεύονται από το νήμα που λαμβάνει τα δεδομένα στα νήματα που είναι υπεύθυνα για την επεξεργασία και την απευθείας αποθήκευση με την χρήση διανυσμάτων των οποίων το μέγεθος είναι δυναμικό (struct ~Vector~). Για την εξάλειψη της πιθανότητας race condition στα διανύσματα, χρησιμοποιήθηκε mutex. Επίσης, για τον υπολογισμό του κινούμενου μέσου όρου χρησιμοποιήθηκε ουρά FIFO πεπερασμένου μήκους (struct ~Queue~). Στην περίπτωση μας έχει μέγεθος ίσο με το μέγιστο πλήθος των λεπτών που συμμετάσχουν στον υπολογισμό, δηλαδή 15. Ακόμη, για τον υπολογισμούς δημιουργούνται πίνακες από struct ~Candle~ και ~MovingAverage~ με πλήθος στοιχείων ίσο με το αριθμό των συμβόλων.

\warningbox{Να σημειωθεί ότι μερικές φορές το FinnHub έχει παρατηρηθεί πως αποστέλλει δεδομένα παλιότερων λεπτών και όχι του τρεχούμενου. Τα δεδομένα που αναφέρονται σε παλιότερα λεπτά επιλέχθηκε στην παρούσα υλοποίηση να αγνοηθούν.}

*** Δομές δεδομένων
Δημιουργήθηκαν τα ακόλουθα structs. Το διάνυσμα και η ουρά δημιουργήθηκαν έτσι, ώστε να μπορούν να επαναχρησιμοποιηθούν για οποιοδήποτε τύπο δεδομένων:
#+BEGIN_SRC c
  typedef struct {
      void* data;
      size_t size;
      size_t capacity;
      size_t elemSize;
      pthread_cond_t* isEmpty;
      pthread_mutex_t* mutex;
  } Vector;
  typedef struct {
        void *data;
        size_t elemSize, head, tail,size,capacity;
        bool isFull, isEmpty;
    } Queue;
   typedef struct {
      	size_t symbolID;
      	time_t timestamp;
      	double price, volume;
      	struct timespec insertionTime;
   } Trade;
   typedef struct {
      	Trade first,last,max,min;
      	double totalVolume;
      	size_t symbolID;
   } Candle;
   typedef struct {
      	Trade first;
      	double totalVolume;
      	double averagePrice;
      	size_t symbolID,tradeCount;
      	time_t stopTime;
   } MovingAverage;
#+END_SRC

*** Υπολογισμός candlestick
Όταν υπάρχουν συναλλαγές στο διάνυσμά του, τότε υπολογίζεται σε πραγματικό χρόνο η μέγιστη και ελάχιστη τιμή του συμβόλου του τελευταίου λεπτού. Όταν περάσει το λεπτό και έρχεται η πρώτη συναλαγή από το επόμενο λεπτό, τότε το τελικό αποτέλεσμα αποθηκεύεται σε ένα struct ~Candle~ και ο υπολογισμός επαναρχικοποιείται.
\pagebreak
*** Υπολογισμός κινούμενου μέσου όρου
Όταν υπάρχουν συναλλαγές στο διάνυσμά του, τότε υπολογίζεται σε πραγματικό χρόνο ο μέσος όρος του τελευταίου λεπτού και προστίθεται στην ουρά. Αν υπάρχουν δεδομένα στην ουρά παλιότερα απο τα τελευταία 15 λεπτά, διαγράφονται από την μνήμη και αφαιρούνται απο τον τελικό μέσο όρο. Επομένως, όταν έρθει η πρώτη συναλλαγή από το επόμενο λεπτό, αν η ουρά έχει γεμίσει επειδή έχουμε συμπληρώσει τα τελευταία 15 λεπτά ή να μην έχει γεμίσει έχουμε διαγράψει δεδομένα από αυτή, το οποίο συμβαίνει όταν για παράδειγμα δεν έχουμε συναλλαγές για κάποια λεπτά, τότε υπολογίζεται και αποθηκεύεται ο τελικός μέσος όρος σε ένα struct ~MovingAverage~ και ο υπολογισμός επαναρχικοποιείται.

\notebox{Σε περίπτωση που έχουμε μπει στο επόμενο λεπτό, δεν έχουν έρθει συναλλαγές ακόμα του επόμενου λεπτού, και το νήμα που αποθηκεύει τα στατιστικά πρέπει να ξεκινήσει να ανανεώνει τα αρχεία, τότε χρησιμοποιούνται τα τελευταία στατιστικά, όταν είναι αυτό δυνατό. Για να μειωθεί η πιθανότητα να συμβεί αυτό και να έχουμε ακριβέστερη πληροφορία, το νήμα δίνει μια "περίοδο χάριτος" 15 δευτερολέπτων πριν ξεκινήσει την ανανέωση των αρχείων.}

* Αποτελέσματα
** Τεχνικές πληροφορίες
Το πρόγραμμα εκτελέστηκε σε ένα Raspberry Pi 1 model B με τα εξής τεχνικά χαρακτηριστικά:
- CPU: ARM1176JZFS @ 700 MHz (1 core)
- Αρχιτεκτονική: ARMV6
- RAM: 512 MB

Για την αποθήκευση των δεδομένων χρησιμοποιήθηκε μια Class 10 SD 64GB card. Επομένως, όπως είναι ήδη φανερό, τα πιθανά bottlenecks στην επίδοση πέραν της υλοποίησης φυσικά, είναι η CPU και η ταχύτητα εγγραφής της κάρτας SD (random write). Η βιβλιοθήκη libwebsockets είναι statically linked με το υπόλοιπο πρόγραμμα. Για τον υπολογισμό του χρόνου αδράνειας της CPU και του χρόνου χρήσης της CPU από το πρόγραμμα χρησιμοποιήθηκε το εργαλείο perf[cite:@sites:perf-wiki] τρέχοντας την εξής εντολή ταυτόχρονα, στο παρασκήνιο:

#+begin_src bash
perf stat -p <pid> -e task-clock,cache-references,cache-misses,context-switches,branch-misses,branches -o perf.txt
#+end_src
Τέλος, τα σύμβολα που επιλέχθηκαν είναι BINANCE:BTCUSDT, ORCL, AMD, BINANCE:ETHEUR, OANDA:XAU_EUR και KRAKEN:XXMRZEUR. Επιλέχθηκαν έτσι ώστε να διαφέρουν στην συχνότητα και την ποσότητα των συναλλαγών, καθώς και για να καλυφθούν όλα τα είδη των συναλλαγών.

\pagebreak
** Αδράνεια CPU
Σύμφωνα με την έξοδο του perf (βλέπε το αρχείο [[https://github.com/thetonk/tradestats/blob/main/report/perf.txt][perf.txt]]) ο χρόνος που εκτελέστηκε το πρόγραμμα ήταν περίπου 273996 δευτερόλεπτα και η διάρκεια που χρησιμοποίησε την CPU ήταν περίπου 12875 δευτερόλεπτα. Επομένως το ποσοστό της αδράνειας της CPU είναι _96%_, το οποίο είναι ένα καλό ποσοστό για εφαρμογή που τρέχει σε ενσωματωμένο σύστημα, διότι εξοικονομεί ενέργεια.

** Διαγράμματα
*** Κατανομή χρόνου επεξεργασίας συναλλαγών
#+ATTR_LATEX: :float nil :width \linewidth
#+CAPTION: Ιστογράμματα χρόνου επεξεργασίας ανά σύμβολο
[[./images/histogram-per-symbol.png]]

*** Πόροι συστήματος
#+ATTR_LATEX: :float nil :width 0.7\linewidth
#+CAPTION: Συνολικό ποσοστό χρήσης του επεξεργαστή από το user space κατά την εκτέλεση
[[./images/cpu-usage.png]]

#+ATTR_LATEX: :float nil :width 0.7\linewidth
#+CAPTION: Συνολική χρήση μνήμης κατά την εκτέλεση
[[./images/memory-usage.png]]

#+PRINT_BIBLIOGRAPHY: :heading bibnumbered
